Password: The uncapacitated facility location problem is one of choosing sites among a set of candidates in which facilities can be located, so that the demands of a given set of clients are satisfied at minimum costs. Applications of neighborhood search methods to this problem have not been reported in the literature. In this paper we first describe and compare several neighborhood structures used by local search to solve this problem. We then describe neighborhood search heuristics based on tabu search and complete local search with memory to solve large instances of the uncapacitated facility location problem. Our computational experiments show that on medium sized problem instances, both these heuristics return solutions with costs within 0.075% of the optimal with execution times that are often several orders of magnitude less than those required by exact algorithms. On large sized instances, the heuristics generate low cost solutions quite fast, and terminate with solutions whose costs are within 0.0345% of each other. Keywords Uncapacitated facility location ; Heuristics ; Greedy ; Local search ; Tabu search ; Complete local search with memory 1. Introduction Location problems are some of the most widely studied problems in combinatorial optimization (see [12] for a detailed introduction). The basic setting of the problems is the following. We have a set of sites in which facilities can be located, and a set of clients who have requirements that are to be satisfied by the facilities to be set up. The objective is to determine the sites in which facilities must be set up to satisfy the client requirements at minimum cost. Based on additional assumptions, location problems can be classified into four basic categories: p -median problems, p -center problems, uncapacitated facility location problems, and capacitated facility location problems. In this paper we consider the uncapacitated facility location problem (UFLP). In this problem the cost of satisfying the client requirements has two components––a fixed cost component of setting up a facility in a given site, and a transportation cost component of satisfying the client requirements. Capacities of all the facilities in the UFLP are assumed to be infinite. Formally defined, the UFLP is the following problem: Problem: Uncapacitated Facility Location Instance: Sets I ={ i 1 , i 2 ,…, i m } of sites in which facilities can be located, J ={ j 1 , j 2 ,…, j n } of clients, a vector F =( f i ) of fixed costs for setting up facilities at sites i ∈ I , and a matrix C =[ c ij ] of transportation costs from i ∈ I to j ∈ J . Output: The size of a UFLP instance is denoted by m × n , where m and n are the cardinalities of the sets I and J respectively. Each set S (∅⊂ S ⊆ I ) represents a solution to the instance according to the rule: i ∈ S ⇔ a facility is located in site i in the solution represented by S . The UFLP forms the underlying model in several combinatorial problems, like set covering, set partitioning, information retrieval, simplification of logical Boolean expressions, airline crew scheduling, vehicle despatching [3] , assortment (among others [1] , [9] , [13]  and  [14] ), and is a subproblem for various location analysis problems [15] . The function is called the cost or the objective function of the solution S . The UFLP is known to be -hard [4] , and many exact and heuristic algorithms to solve the problem have been discussed in the literature. An annotated bibliography of several exact solution approaches appears in [11] . Methods for generating challenging data sets of large instances of these problems have been suggested in [10] . Neighborhood search based methods have been overlooked for the UFLP, although a tabu search (TS) based method for solving the related p -median problem has been reported (see [16] ). A TS procedure for the location–allocation problem has also been reported in [17] . Our aim in this paper is to study neighborhood search based methods for the UFLP. In Section 2 we study the performance of the steepest descent local search heuristic using various neighborhood structures. We choose the neighborhood structure among these that performs best on test problems, and discuss implementations of TS and complete local search with memory (CLM) using this neighborhood structure in Section 3 . We report our computational experience with TS and CLM on randomly generated large instances of the UFLP in Section 4 , and summarize the paper in Section 5 . 2. Local search and choice of neighborhoods Local search is perhaps the simplest among neighborhood search methods. It starts with a given initial solution as the current solution and checks its neighborhood for a better solution. If such solutions exist, then local search designates the best solution found in the neighborhood as the current solution and repeats the process. In case the neighborhood of the current solution does not contain any solution better than it, local search returns the current solution and terminates. This method does not guarantee globally optimal solutions to most combinatorial problems, but generally returns relatively good quality solutions. Of course, the effectiveness of the method depends on the neighborhood structure used. In this section we test the performance of local search on UFLP instances using three neighborhood structures, the Add-Swap neighborhood, the 2-Swap neighborhood, and the Permutation neighborhood. 2.1. Neighborhood structures Add-Swap neighborhood: This neighborhood structure was used in [17] to solve location problems. The neighborhood is defined using two different kinds of moves: swap moves and add moves. A swap move removes a facility from one of the sites where it was located in the current solution and simultaneously opens a facility in a site that had none. This kind of move keeps the number of open facilities in the solution constant. An add move , on the other hand, simply opens a facility in one of the sites where no facility was open in the current solution. Thus it increases the number of opened facilities by one. The local search procedure on which the TS procedure described in [17] is based starts by opening a facility in one of the locations on the instance. It then enters a swap phase in which swap moves are executed until no more swap moves improve the solution. After that, local search enters an add phase in which add moves are executed until no more add moves improve the solution. The swap and add phases alternate until a local optimum is reached with respect to both add and swap moves. 2-Swap neighborhood: This is a very common neighborhood structure used in combinatorial optimization problems. In this neighborhood, a move from a solution to another can be executed by one of three ways––either by executing an add move, or by executing a swap move, or by removing a facility from one of the sites where it was located in the current solution. Permutation neighborhood: Since the objective function value of the UFLP is supermodular, the following result holds true. Result 1 [2] . Consider solutions S 1 , S 2 ,…, S m , where | S k |= k and ∅= S 0 ⊂ S 1 ⊂ S 2 ⊂…⊂ S m = I . Assume that . Then there exists p , 1⩽ p ⩽ m such that This result allows us to define the greedy heuristic GREEDY of Fig. 1 that runs in time.