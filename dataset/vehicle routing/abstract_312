  We generalize the standard vehicle routing problem with time windows by allowing both traveling times and traveling costs to be time-dependent functions. In our algorithm, we use a local search to determine routes of the vehicles. When we evaluate a neighborhood solution, we must compute an optimal time schedule for each route. We show that this subproblem can be efficiently solved by dynamic programming, which is incorporated in the local search algorithm. The neighborhood of our local search consists of slight modifications of the standard neighborhoods called 2- opt ∗ , cross exchange and Or-opt. We propose an algorithm that evaluates solutions in these neighborhoods more efficiently than the ones computing the dynamic programming from scratch by utilizing the information from the past dynamic programming recursion used to evaluate the current solution. We further propose a filtering method that restricts the search space in the neighborhoods to avoid many solutions having no prospect of improvement. We then develop an iterated local search algorithm that incorporates all the above ingredients. Finally we report computational results of our iterated local search algorithm compared against existing methods, and confirm the effectiveness of the restriction of the neighborhoods and the benefits of the proposed generalization. Keywords Vehicle routing problem ; General time windows ; Time-dependent traveling time and cost ; Dynamic programming ; Local search ; Metaheuristics 1. Introduction The vehicle routing problem (VRP) is the problem of minimizing the total travel distance of a number of vehicles, under various constraints, where every customer must be visited exactly once by a vehicle [1] , [2]  and  [3] . This is one of the representative combinatorial optimization problems and is known to be NP-hard. The traveling salesman problem (TSP) can be viewed as a special case of VRP in which the number of vehicles is one. TSP has been intensively studied for many decades  [4] and VRP is under intensive study as well. Among variants of VRP, the VRP with capacity and time window constraints, called the vehicle routing problem with time windows (VRPTW), has been widely studied in the last decade [5] , [6] , [7]  and  [8] . The capacity constraint signifies that the total load on a route cannot exceed the capacity of the assigned vehicle. The time window constraint signifies that each vehicle must start the service at each customer in the period specified by the customer. The VRPTW has a wide range of applications such as bank deliveries, postal deliveries, school bus routing and so on, and has been a subject of intensive research focused mainly on heuristic and metaheuristic approaches. See extensive surveys by Bräysy and Gendreau [9]  and  [10] for heuristic and metaheuristic approaches. A constraint is called hard if it must be satisfied, while it is called soft if it can be violated. The violation of soft constraints is usually penalized and added to the objective function. The VRP with hard (resp., soft) time window constraints is abbreviated as VRPHTW (resp., VRPSTW). For VRPHTW, even just finding a feasible schedule with a given number of vehicles is known to be NP-complete in the strong sense, because it includes the (one-dimensional) bin packing problem as a special case  [11] . Hence it may not be reasonable to restrict the search only within the feasible region of VRPHTW, especially when the constraints are tight. Moreover, in real-world situation, time window and capacity constraints can be often violated to some extent. Considering these, the two constraints (i.e., time window constraint and capacity constraint) are treated as soft in this paper. To evaluate constraint violation, we use cost functions, which can be nonconvex and/or discontinuous as long as they are piecewise linear. This formulation is quite general; e.g., one or more time slots can be assigned to each customer. In real situations, traveling times are often dependent on the departure times and they cannot be treated as constants in such cases (e.g., rush-hour traffic jam). For TSP, the generalization with time-dependent traveling times is called the time-dependent traveling salesman problem (TDTSP) and is well-studied [12] , [13]  and  [14] . On the contrary, to the best of our knowledge, not much has been investigated on similar generalizations of VRPTW except for a few papers. Ichoua et al.  [15] considered a formulation in which each customer has only one time window. Desaulniers et al.  [16] presented a branch-and-bound framework for a very general model that can handle time-dependency and various other issues. In this paper, we introduce traveling time and cost functions between each customer, whose values are dependent on the start time of traveling. These functions can be nonconvex and/or discontinuous as long as they are piecewise linear. Although we assume some property for each traveling time function, any functions satisfying the FIFO condition considered in  [15] can still be represented, and the problem is fairly general. Our model generalizes that of Ichoua et al. in that it can allow more flexible time penalty function for each customer, and that of Ibaraki et al.  [17] in that it can treat time-dependent traveling time and cost. In our algorithm, we use local search to determine the routes of vehicles. When we evaluate a neighborhood solution, we need to solve the problem of determining the optimal start times on each route. In Ichoua et al., they solve this subproblem approximately (for their restricted formulation), but solve it exactly only for the best M M -approximate neighborhood solutions ( M M is a parameter). We show that this subproblem can be efficiently solved with dynamic programming. The time complexity of our dynamic programming algorithm is the same as that of Ibaraki et al.  [17] in spite of its generality if each traveling time and cost is a constant. This dynamic programming is incorporated in the local search algorithm. In our local search, we use the standard neighborhoods called 2- opt ∗ , cross exchange and Or-opt with slight modifications. We can evaluate the solutions in these neighborhoods efficiently by utilizing the information from the past dynamic programming recursion. We further propose a filtering method to restrict the search in the neighborhoods to avoid many solutions having no prospect of improvement. For the 2- opt ∗ neighborhood, even with this restriction, we will not miss a better solution in the neighborhood if there is any. We develop an iterated local search algorithm incorporating all the above ingredients. Finally we report computational results on benchmark instances, and confirm the effectiveness of the restriction of the neighborhood. We compare the performance of our iterated local search algorithm against existing methods, and discuss the benefits of the proposed generalization.