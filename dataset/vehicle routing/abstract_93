Password: The standard vehicle routing problem was introduced in the OR/MS literature about 45 years ago. Since then, the vehicle routing problem has attracted an enormous amount of research attention. In the late 1990s, large vehicle routing problem instances with nearly 500 customers were generated and solved using metaheuristics. In this paper, we focus on very large vehicle routing problems. Our contributions are threefold. First, we present problem instances with as many as 1200 customers along with estimated solutions. Second, we introduce the variable-length neighbor list as a tool to reduce the number of unproductive computations. Third, we apply record-to-record travel with a variable-length neighbor list to 32 problem instances and obtain high-quality solutions, very quickly. Keywords Vehicle routing problem ; Metaheuristics 1. Introduction The standard version of the capacitated vehicle routing problem (VRP) is easy to state and very difficult to solve: Generate a sequence of deliveries for each vehicle in a homogeneous fleet based at a single depot so that all customers are serviced and the total distance traveled by the fleet is minimized. Each vehicle has a fixed capacity and must leave from and return to the depot. Each vehicle might have a route-length restriction that limits the maximum distance it can travel. Each customer has a known demand and is serviced by exactly one visit of a single vehicle. In the last 5 years, there has been a great deal of computational effort devoted to solving the 20 large-scale vehicle routing problems (denoted by LSVRPs) developed by Golden et al. [1] . These benchmark problems have 200–483 customers. Eight problems have route-length restrictions. Each problem has a geometric symmetry that allows a user to estimate a high-quality solution (eight problems have customers located in concentric circles around the depot, four problems have customers located in concentric squares with the depot located in one corner, four problems have customers located in concentric squares around the depot, and four problems have customers located in a six-pointed star around the depot). Researchers have applied general-purpose metaheuristics including deterministic annealing and tabu search to the 20 LSVRPs and have generated high-quality solutions. In Section 2 , we review six algorithms that have been used by researchers to solve the large-scale problems, develop an improved version of our record-to-record travel algorithm that uses a variable-length neighbor list, and report computational results for all seven procedures. In Section 3 , we develop a new set of 12 very large-scale vehicle routing problems (denoted by VLSVRPs). The problems have 560–1200 customers, route-length restrictions, and exhibit geometric symmetry. We report computational experience with our variable-length neighbor list record-to-record travel algorithm and compare results to the visually estimated solutions. In Section 4 , we summarize our findings and suggest areas for future work. 2. Solving LSVRPs: new algorithms and results In the last 5 years, a variety of algorithms have been developed to solve the 20 LSVRPs. Researchers have used deterministic variants of simulated annealing (record-to-record travel, back tracking adaptive threshold accepting, and list-based threshold accepting) and variants of tabu search (network flow-based tabu search, adaptive memory-based tabu search, and granular tabu search). We summarize these six algorithms in Table 1 . Table 1. Six algorithms for solving the large-scale vehicle routing problem Authors Algorithm Comments Golden et al. [1] Record-to-record travel An initial solution is generated by the Clarke and Wright algorithm. Feasible one-point moves are made using record-to-record travel (uphill moves allowed). Points are exchanged on different routes (two-point exchange) while feasibility is maintained (uphill moves allowed). Routes are cleaned up (only downhill moves allowed). A local reinitialization allows individual routes to be resequenced and the process of one-point moves, two-point exchanges, and clean-up is repeated. At the end, global reinitialization perturbs the best solution and the process of one-point moves, two-point exchanges, and clean-up is repeated. Golden et al. [1] Network flow-based tabu search The authors used the algorithm of Xu and Kelly [4] where insertion and swap moves are controlled by a network flow model. Infeasible solutions that violate capacity are allowed. Tarantilis and Kiranoudis [5] Adaptive memory-based tabu search The key idea is to extract a sequence of points (called bones) from a set of solutions and generate a route using adaptive memory. If a large number of routes in the set of solutions contains a specific bone, then the authors argue that this bone should be included in a route that appears in a high-quality solution. The BoneRoute algorithm has two phases. In Phase I, a set of initial solutions is generated using weighted savings. The solutions are improved using a standard tabu search algorithm. In Phase II, promising bones are extracted, a solution is generated and improved using tabu search, and the set of solutions is updated. Toth and Vigo [6] Granular tabu search The authors define a granular neighborhood for the VRP by considering short edges (these are edges whose lengths are less than a threshold value) and by typically not considering long edges. Granular neighborhoods are similar in concept to neighbor list strategies. A granular tabu search algorithm is developed. The algorithm starts with a Clarke and Wright solution (infeasible solutions are allowed) and uses granularity-based intensification and diversification during the search. Tarantilis [7] Backtracking adaptive threshold accepting List-based threshold accepting Threshold accepting is a deterministic variant of simulated annealing in which a threshold value T is specified as the upper bound on the amount of objective function increase allowed (uphill moves can be made). In the backtracking algorithm, T is allowed to increase during the search. In the list-based algorithm, a list of values for T is used during the search. Full-size table We set out to develop an improved version of the record-to-record travel algorithm (denoted by RTR) described in Golden et al. [1] that would be accurate, fast, simple, and flexible (this was motivated by the work of Cordeau et al. [2] ). The details of our improved algorithm are given in Table 2 . Our algorithm (denoted by VRTR) uses a variable-length neighbor list. The idea is to consider only a fixed number of neighbors for each node when making one-point, two-point, and two-opt moves. We start with a traditional fixed-length neighbor list with k =40 nearest neighbors (fixed-length neighbor lists are not new; we used this type of implementation in work on the traveling salesman problem [3] ). For each node i , we remove all edges (for nodes in the neighbor list) with length greater than α × L , where L is the maximum length among all edges in i 's neighbor list. When α is equal to 1, we consider k =40 edges. When α is less than 1, we consider fewer edges. In general, we expect that as α decreases, so does running time and accuracy suffers. Our variable-length neighbor list is similar to the granular neighborhood developed by Toth and Vigo [6] for the VRP.