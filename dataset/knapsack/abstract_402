  We propose an efficient dynamic programming algorithm for solving a bilevel program where the leader controls the capacity of a knapsack, and the follower solves the resulting knapsack problem. We propose new recursive rules and show how to solve the problem as a sequence of two standard knapsack problems. Keywords Knapsack problem ; Bilevel programming ; Dynamic programming 1. Introduction Bilevel programs (see Colson et al.  [1] for a survey or Dempe  [9] ) allow the modeling of situations in which a decision-maker, hereafter the leader, optimizes his objective by taking the follower’s response to his decisions explicitly into account. In the case of the Bilevel Knapsack Problem ( BKP ), the leader determines the knapsack’s capacity in order to maximize his profit, while the follower faces a 0–1 knapsack problem  [2] involving the capacity set by the leader. BKP is well suited to model the “right financing problem”, where an individual (the leader) shares his capital between a savings account with fixed rate of return and a more risky investment, through an intermediary, such as a bank or a broker. The intermediary (the follower) (i) buys shares or bonds to maximize his revenue while respecting the leader’s budget constraint (knapsack constraint) and (ii) obtains a return from his own investments. Similar applications occur in the field of revenue management  [3] , where a company may decide on the number of units to sell by itself or to hand over to an intermediary. The BKP is a mixed integer bilevel program introduced by Dempe and Richter  [4] , who proposed for its solution a branch-and-bound framework. In this work, we first extend Dempe and Richter’s necessary and sufficient conditions for the existence of an optimal solution. Next, we propose a simple and efficient dynamic programming algorithm for its solution. In contrast with the approach of Dempe and Richter, where a list of undominated solutions is maintained, only the objective function values for both the leader and the follower are saved throughout the dynamic programming process here. Feasibility is implicitly controlled in the course of the algorithm. Under some assumptions, the BKP can be formulated as a sequence of knapsack problems involving binary variables, one for each integer leader variable. This yields an algorithm that outperforms by orders of magnitude alternative approaches based on branch-and-bound schemes.