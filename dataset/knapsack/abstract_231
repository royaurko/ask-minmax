  The 0–1 quadratic knapsack problem (QKP) consists in maximizing a quadratic pseudo-Boolean function with positive coefficients subject to a linear capacity constraint. In this paper we present an exact method to solve this problem. This method makes use of the computation of an upper bound for (QKP) which is derived from Lagrangian decomposition. It allows us to find the optimum of instances with up to 150 variables whatever their density, and with up to 300 variables for medium and low density. Keywords 0–1 quadratic programming ; Knapsack ; Lagrangian decomposition ; Branch-and-bound ; Computational results 1. Introduction A quadratic pseudo-Boolean function f : is defined as follows: where K , and are real coefficients. The quadratic knapsack problem (QKP) consists in maximizing a quadratic pseudo-Boolean function with positive coefficients subject to a linear capacity constraint. This problem has been introduced by Gallo et al. (1980) and may be expressed as follows: where the coefficients c i , and are positive integers and b is an integer such that max{ a i : i =1,…, n }⩽ b <∑ i =1 n a i . This paper presents an exact method and computational results for (QKP). This method is based on the computation of an upper bound by Lagrangian decomposition presented in Billionnet et al. (1999) . We invite the reader to consult this reference where the computation of the bound is detailed. In this reference we also presented some applications of (QKP) and we drew up the state-of-the-art relating to this problem. We should now point out the recent work of Caprara et al. (1999) who also propose an exact method based on Lagrangian relaxation for solving (QKP). Their very efficient algorithm solves (QKP) instances with up to 120 variables for low density problems and with up to 400 variables for high density problems, whereas the best methods previously proposed in the literature did not mention any solution of instances with more than 100 variables. We will show that our respective works pleasantly complement one another since our method turns out to be very efficient for low and medium density problems: we can solve such problems with up to 300 variables. Our method also enables us to solve 150-variable problems regardless of their density. In the second section of this paper, we briefly explain the computation of the lower bound and also the main steps in the computation of the upper bound. In the third section, we describe a variable fixing procedure which is relatively original. In the fourth section, the branch-and-bound algorithm is presented. In the fifth section, we report computational results and the sixth section is a conclusion. 2. Lower and upper bounds computation 2.1. Lower bound computation A feasible solution is determined by the algorithm proposed by Billionnet and Calmels (1996) . This algorithm is composed of two parts. The first one uses the greedy heuristic presented by Chaillou et al. (1986) ; the second one consists in improving the obtained feasible solution by the fill-up and exchange procedure proposed by Gallo et al. (1980) . Computational experiments show that this algorithm almost always provides a feasible solution which is very close to the optimum, and even often equal to the optimum. Typically, for randomly generated instances with up to 500 variables, the relative gap between the value of this solution and the optimum value is less than 2% (see Billionnet et al., 1999 ). This solution is quickly obtained, in less than 1 second of CPU time on a HP9000 workstation for instances with up to 500 variables. When this method yields a “bad” feasible solution, we try to compute a better one by using a simulated-annealing algorithm (cf. Remark 3.1 at the end of Section 3 ). We will denote by LB the value of the feasible solution found. 2.2. Upper bound computation The upper bound (UB) is computed by the Lagrangian decomposition method presented in Billionnet et al. (1999) , which is an adaptation of the bound proposed by Chardaire and Sutter (1995) for the minimization of an unconstrained quadratic pseudo-Boolean function. The proposed method enables us to find upper bounds with a relative gap of less than 1%. For (QKP) instances with up to 500 variables, we can find such upper bounds within less than one hour on a HP9000 workstation. We briefly summarize below the five stages of the method. The following notations will be used: • X ={ x 1 , x 2 ,…, x n } is the set of the variables of the problem, • { X 1 , X 2 ,…, X p } is a partition of X(1⩽p⩽n) . X k is called cluster k , • Y k = X ⧹ X k , • I k (resp. J k ) is the set of the indices of the variables of X k (resp. Y k ), • x I k is the vector of the variables x i , i ∈ I k (called “complicating” variables), • cl ( i ) is the index of the cluster including x i . The first stage of the decomposition method consists in creating clusters { X 1 , X 2 ,…, X p } that constitute a partition of X .