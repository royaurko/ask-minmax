Password: One line of DNA computing research focuses on parallel search algorithms, which can be used to solve many optimization problems. DNA in solution can provide an enormous molecular library, which can be searched by molecular biological techniques. We have implemented such a parallel search for solutions to knapsack problems, which ask for the best way to pack a knapsack of limited volume. Several instances of knapsack problems were solved using DNA. We demonstrate how the computations can be extended by in vivo translation of the DNA library into protein. This combination of DNA and protein allows for multi-criterion optimization. The knapsack computations performed can then be seen as protein optimizations, one of the most complex computations performed by natural systems. Keywords DNA computing ; Aqueous computing ; Knapsack problem Plasmids (naturally occurring circular DNA molecules) can serve to perform computations at the molecular level (see Paun et al., 2005 , for an introduction to molecular computing). Specially designed plasmids contain a dedicated computing region, which is basically a computer memory with bits set to either 1 or 0. A molecular memory consisting of many plasmids in solution can be operated on by restriction endonucleases. Removal of a region from the plasmid (a ‘station’) is identified with the flipping of a bit ( Head, 2000 ). In theory, all plasmids in a solution can represent different memory configurations and therefore provide a huge parallel search space for optimization problems. Typically, a computation starts with a single species of plasmid, from which a library of different plasmids is generated by repeated modifications to subsets of the plasmid mixture. From this library, a memory configuration corresponding to the solution to a certain problem can be selected using molecular biological separation technologies. Plasmid computing has been successfully applied to small test instances of several computationally hard optimization problems, and can be applied to a broad range of algorithmic problems ( Head et al., 2000  and  Head et al., 2002 ). Recently, we extended plasmid computing with protein expression by the construction of the whole computing region of a plasmid as part of an open reading frame ( Henkel et al., 2005 ). After library generation, the library was expressed into a protein representation, and this was in turn used to select a solution. A potential advantage of this translation of the solution into protein are smaller molecules (which can be analyzed using sensitive mass spectrometry technology) and consequently higher information densities. In this computation both DNA and protein encoded exactly the same information, i.e. the values of bits. However, the translation process can also be taken advantage of by specifying different information in DNA and protein. In this way, the optimization of the solution may be realized according to multiple distinct criteria. On the nucleic acid level, DNA length, presence and sequence are obvious encoding possibilities. Amino acids allow for linear representation of these after translation, but add more complex physico-chemical characteristics such a molecular weight and isoelectric properties. Here, we have solved several instances of knapsack problems using plasmids. These problems ask for the best way to pack a knapsack of limited capacity with items of different size and weight. DNA computing seems very well suited for this family of problems, as both the encoding and the algorithm are relatively straightforward: formal size or weight can be linked directly to physical properties of DNA. In addition, because these problems allow for multi-criterion optimization, both DNA length and protein mass can be used to compute. 2.1. Knapsack problems The knapsack family of problems asks for ways to pack a volume (knapsack) of limited capacity in the most efficient way. The solution depends on the nature of the items to be packed. In some variants, only size is associated with the items—in others, items have both sizes and values, and the efficiency is evaluated by the total value packed in the fixed size knapsack. The problem can be defined as follows: given a set of n items, each with size s i  ∈  N   (natural numbers including 0) and value v i ∈N v i ∈ N , and a knapsack capacity C , maximize: ∑ i = 1 n x i v i   subject to   ∑ i = 1 n x i s i ≤ C , where x i is the multiplicity of item i in the knapsack. In the binary or 0/1 knapsack problem treated here, the availability of each item is limited to one, so x i  ∈ {0,1}. In the unbounded or integer knapsack problem, the supply of each item is unlimited: x i  ∈  N   . If only item size is considered ( s i =v i s i = v i for every item i ), the binary knapsack problem reduces to the subset sum problem: ∑ i = 1 n x i s i ≤ C ,   x i ∈ { 0 , 1 } . All these problems belong to the class NP-complete, which means that no deterministic algorithm is known to solve them in polynomial time, and it is unlikely such an algorithm exists ( Garey and Johnson, 1979 ). However, algorithms exist that can solve certain knapsack variants in pseudo-polynomial time, i.e. in practice their exponential scaling behaviour can be rather mild. Still, the only guaranteed way to solve instances of the knapsack problem is the exhaustive enumeration of all possible knapsack packings. 2.2. Algorithm To implement knapsack problems using plasmids, stations in the computational plasmid ( Fig. 1 ) are identified with items in the knapsack. Other than in previous computations using a similar plasmid (see for instance Henkel et al., 2005 ), presence or absence of the stations is not associated with bit values. Instead, knapsack item sizes are encoded by the length of these stations (the number of basepairs). The items available in plasmid pKnapsack1 are listed in Table 1 .