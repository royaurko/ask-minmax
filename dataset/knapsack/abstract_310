Password: Many combinatorial optimization problems are known to be NP-complete. A common point of view is that finding fast algorithms for such problems using a polynomial number of processors is unlikely. However, facts of this kind are usually established for “worst” case situations, and in practice many instances of NP-complete problems are successfully solved in polynomial time by such traditional combinatorial optimization techniques such as dynamic programming, branch-and-bound. New opportunities for an effective solution of combinatorial problems emerged with the advent of parallel machines. In this paper, we describe an algorithm which generates an optimal solution for the 0/1 integer knapsack problem on DNA computing. Keywords DNA computing ; 0–1 Knapsack problem ; Knapsack problem 1. Introduction The first tools of molecular biology are used to solve an instance of the directed Hamiltonian path problem by Adleman in 1994. A small graph is encoded in the molecules of DNA and the operation of the computation are performed with standard protocols and enzymes. This experiment demonstrates the feasibility of carrying out computations at the molecular level [1] . The result showed that not only can DNA be used to solve a computationally difficult problem, but it also demonstrated the potential power of parallel, high-density computation of DNA molecules in solution. This parallelism allows DNA computers to solve painstaking problems such as the NP-complete problem with linearly increasing time, as compared with the exponentially increasing time required by the Turing machine. In this paper, we solve the 0–1 knapsack problem by DNA computing. The proposed approach involves the incubation of the solution space that contains the “sticker” DNA strands. Adleman [4] introduced an abstract model of molecular computation, called the “sticker model”, which has random access memory to exploit information encoding. Its error rate of hybridization is lower than that of the Adleman–Lipton model. The sticker model breaks the strand into bit strings of which each bit comprises several DNA molecules. A sticker is complementary to one and only one bit string. A DNA-based algorithm is developed to demonstrate a general solution based on the operations defined in Adleman experiments [2] . The rest of this paper is organized as follows: Section 2 introduces the 0–1 knapsack problem and Section 3 then presents the DNA algorithm for the 0–1 knapsack problem. Conclusions are finally drawn in Section 4 , along with a summary of the results. 2. Binary knapsack (BKP) problem Knapsack problems have been studied intensively in the last decade, attracting both theorists and practicians. The theoretical interest arises mainly from their simple structure, which, on the one hand, allows the exploitation of a number of combinatorial properties and, on the other hand allows more complex optimization problems to be solved through a series of knapsack-type subproblems. From a practical point of view, these problems can model many industrial situations (e.g., capital budgeting, cargo loading, and cutting stock) as well as most classical applications. Suppose that we want to fill up a knapsack by selecting some objects among various objects (generally called items). There are n different items available and each item j has a weight of w j and a profit of p j . The knapsack can hold a weight of at most W . The problem is to find an optimal subset of items so as to maximize the total profits subject to the knapsack’s weight capacity. The profits, weights, and capacities are positive integers. Let x j be binary variables given as follows: x j = 1 if item j is selected, 0 otherwise . The kanapsack problem can be mathematically formulated as follows: max ∑ j = 1 n p j x j , s.t. ∑ j = 1 n w j x j ⩽ W , x j = 1 or 0 , j = 1 , 2 , … , n . This is known as the 0–1 knapsack problem, which is pure integer programming with a single constraint and forms a very important class of integer programming. 3. DNA computing for solution BKP DNA is a high-molecular weight compound. Its basic composition includes one phosphate group, one deoxyribose sugar, and one nitrogenous base. There are four kinds of nitrogenous bases: adenine (A), guanine (G), cytosine (C), and thymine (T). DNA is a double helix consisting of two single strand deoxynucleotide chains running in an antiparallel configuration. After determining the precise structure of DNA, many experimental methods have been invented including annealing, amplifying, melting, separating, cutting, ligating, and so on, which can be used to help discover the mechanisms of information storage and output. The basic assumptions are that the data can be encoded in DNA strands and are error-free, and that molecular biologic technologies can perform all computational operations. The models of DNA computing are based on different combinations of the following biological operations on DNA strands: 1. Melting/annealing: break apart/bond together two single DNA strands with complementary sequences. 2. Synthesis of a desired DNA strand of polynomial length. 3. Separation of the strands by length. 4. Merging: pour two (or more) test tubes into one. 5. Extraction: extract the strands that contain a given pattern as a substring. 6. Amplifying: make copies of DNA strands by using the polymerase chain reaction (PCR). 7. Polymerization: transform a single strand that has a portion of double-stranded subsequence into an entire double-stranded molecule. 8. Cutting: cut DNA strands by using restriction enzymes. 9. Ligation: paste DNA strands with complementary sticky ends by using ligases. 10. Substitution: substitute, insert, or delete DNA sequences by using PCR site-specific oligonucleotide mutagenesis. 11. Marking single strands by hybridization. 12. Destroying the marked strands. 13. Detection: given a tube, check if it contains at least one DNA strand. 14. Number: given a tube, count many DNA strands in it. 15. Clear: a test tube is denoted by T . Consider a particular bit position “ p ”, the operation logically turns bit position p “off ” (value 0) on every strand in tube T . These operations are used to “molecular programs”, whose input is a tube with DNA strands or molecules is “yes”, “no” or (set of) tube(s) [3] . 3.1. Algorithm Step 1: Define strand. • Step 2: Generate solution space. • Step 3: Eliminate infeasible solution not complying with constraint. • Step 4: Calculate the value for objective function per strand. • Step 5: Compare the objective function value for all strands.