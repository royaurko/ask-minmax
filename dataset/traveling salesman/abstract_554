Password: Data structures play a crucial role in the efficient implementation of local search algorithms for problems that require circuit optimization in graphs. The traveling salesman problem (TSP) is the benchmark problem used in this study where two implementations of the stem-and-cycle (S&C) ejection chain algorithm are compared. The first implementation uses an Array data structure organized as a doubly linked list to represent TSP tours as well as the S&C reference structure. The second implementation considers a two-level tree structure. The motivation for this study comes from the fact that the S&C neighborhood structure usually requires subpaths to be reversed in order to preserve a feasible orientation for the resulting tour. The traditional Array structure proves to be inefficient for large-scale problems since to accomplish a path reversal it is necessary to update the predecessor and the successor of each node on the path to be reversed. Computational results performed on a set of benchmark problems up to 316,228 nodes clearly demonstrate the relative efficiency of the two-level tree data structure. Keywords Traveling salesman ; Local search ; Data structures ; Ejection chains 1. Introduction Generically, the traveling salesman problem (TSP) consists in sequentially visiting a set of clients (cities, locations) only once and finally returning to the initial client. The goal is to find the tour of minimum total distance (or other cost measure associated with the performed trajectory). In graph theory, the problem can be defined as a graph G =( V , A ) with n vertices (or nodes) V ={ v 1 ,…, v n } and a set of edges with a non-negative cost (or distance) matrix C =( c ij ) associated with A . The problem's resolution consists in determining the minimum cost Hamiltonian cycle on the problem graph. In this paper, we consider the symmetric version of the problem ( c ij = c ji ), which satisfies the triangular inequality ( c ij + c jk ⩾ c ik ). The TSP is well known as a NP-hard combinatorial problem; hence, there is no algorithm capable to solve all possible instances in polynomial time. Consequently, it becomes absolutely necessary to use heuristic (or approximate) algorithms to provide solutions that are as good as possible but not necessarily the optimal. The importance of obtaining efficient heuristics to solve large-scale TSPs recently motivated Johnson, McGeogh, Glover, and Rego to organize the “8th DIMACS Implementation Challenge” specific for TSP algorithms [5] . This paper is based on the development of several algorithmic components and data structures with the purpose of improving the efficiency of the stem-and-cycle algorithm described in Rego [9] . A fundamental aspect forming the basis for this study concerns the following. The data structure representation of a symmetric TSP tour requires the specification of an orientation by which the tour can be read (or traversed), even though the cost of crossing in one direction or in the opposite direction is equivalent. The relevance of this orientation becomes more evident with local search algorithms where moves often require the reversal of a subpath in order to preserve an admissible orientation for a TSP tour. A typical example of the need to reverse paths occurs in the application of classic procedures of the type k -optimal, initially proposed for the TSP [7] . The same phenomenon occurs with the moves generated in some subpath using ejection chain methods, in particular those oriented by a reference structure. Naturally, the need to reverse paths at each iteration of the algorithm requires a computational effort that becomes particularly relevant when large-scale problems have to be solved. The choice of the data structure to represent TSP solutions is crucial when applying neighborhood structures that require path reversals, since the algorithm's complexity might drastically be reduced. Fredman et al. [2] show the relevance of that choice on their implementation of the Lin–Kernighan algorithm [8] by comparing the computational times obtained by several implementations using four different data structures: Array, splay-tree, two-level tree and segment tree. The main goal of this study consists in analyzing and validating the potential of the two-level tree data structure in reducing the running time of the stem-and-cycle algorithm [9] with the aim of improving the algorithm's efficiency in solving large-scale problems. The motivation for this study comes from the fact that the stem-and-cycle algorithm has proved to be extremely effective and competitive with the best algorithms for the TSP [3]  and  [6] . We therefore anticipated that the algorithm's efficiency when solving large scale problems can be improved by the implementation of a data structure specifically designed to reduce the computational complexity associated with the path reversal operations needed at each iteration of the algorithm. 2. Data structures for the S&C procedure 2.1. The stem-and-cycle reference structure The stem-and-cycle (S&C) reference structure is described in Glover [4] and used in the subpath ejection algorithm described in Rego [9] for the TSP. In graph theory, the S&C structure is defined by a spanning subgraph of G , consisting of a path ST=( v t ,…, v r ) called the stem, attached to a cycle CY=( v r , v s 1 ,…, v s 2 , v r ). Vertex v r in common to the stem and the cycle is called the root and, consequently, its adjacent vertices v s 1 and v s 2 are called subroots. Finally vertex v t is called the tip of the stem. Fig. 1 shows a representation of the stem-and-cycle structure. Fig. 1.  The ejection chain method starts by creating the S&C structure from an initial tour. This is done by linking two nodes of the tour and removing one of the edges adjacent to one of those nodes. The selection of the edge to be removed immediately defines the root node for the entire ejection chain. Fig. 2 illustrates one of the possibilities to create the initial S&C structure. In the example, dotted lines represent the edges to be inserted in the new solution and the dashed lines point out possible edges to be removed from the solution. This representation will be adopted in all the figures describing moves through out this paper.