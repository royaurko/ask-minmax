Password: The generalized traveling salesman problem is a variation of the well-known traveling salesman problem in which the set of nodes is divided into clusters; the objective is to find a minimum-cost tour passing through one node from each cluster. We present an effective heuristic for this problem. The method combines a genetic algorithm (GA) with a local tour improvement heuristic. Solutions are encoded using random keys, which circumvent the feasibility problems encountered when using traditional GA encodings. On a set of 41 standard test problems with symmetric distances and up to 442 nodes, the heuristic found solutions that were optimal in most cases and were within 1% of optimality in all but the largest problems, with computation times generally within 10 seconds. The heuristic is competitive with other heuristics published to date in both solution quality and computation time. Keywords Traveling salesman ; GTSP ; Genetic algorithms ; Random keys ; Metaheuristics The generalized traveling salesman problem (GTSP) is a variation of the well-known traveling salesman problem in which not all nodes need to be visited by the tour. In particular, the set V of nodes is partitioned into m sets, or clusters, V 1 , … ,  V m with V 1  ∪ ⋯ ∪  V m  =  V and V i  ∩  V j  = ∅ if i  ≠  j . The objective is to find a minimum-length tour containing exactly one node from each set V i . Applications of the GTSP include postal routing [19] , computer file sequencing [16] , order picking in warehouses [27] , process planning for rotational parts [5] , and the routing of clients through welfare agencies [35] . In addition, many other combinatorial optimization problems can be reduced to, or have as a subproblem, the GTSP (see [19] ). The GTSP is NP-hard, since the TSP is a special case obtained by partitioning V into ∣ V ∣ subsets, each containing one node. In this paper we present a heuristic approach to solving the GTSP. A given instance of the GTSP may use “symmetric” distances, in which the distance from node i to node j is the same as the distance from j to i , or “asymmetric” distances; there are theoretical and computational consequences of using one type of distance metric or the other. For example, the GTSP is often transformed into an equivalent TSP, but many such transformations depend on whether or not the problem is symmetric. Similarly, a given algorithm’s computational performance may be quite different when applied to different types of instances. We test our heuristic on a standard test-bed of symmetric instances. 1.2. Genetic algorithms A genetic algorithm (GA) is a metaheuristic inspired by the efficiency of natural selection in biological evolution. Genetic algorithms have been applied successfully to a wide variety of combinatorial optimization problems and are the subject of numerous recent books [26] , [30] , [39] , [40]  and  [41] and conference proceedings [1] , [2] , [4]  and  [17] . Unlike traditional heuristics (and some metaheuristics like tabu search) that generate a single solution and work hard to improve it, GAs maintain a large number of solutions and perform comparatively little work on each one. The collection of solutions currently under consideration is called the population . Each member of the population (called an individual or a chromosome ) is an encoded version of a solution. The encoding strategy is different for different optimization problems, and a given problem may have more than one workable encoding strategy. The goal of any encoding is to translate a solution into a string of genes that make up the chromosome, just as in biological genetics. Each iteration of a GA consists of several operators that construct a new generation of solutions from the old one in a manner designed to preserve the genetic material of the better solutions (survival of the fittest). Many GA operators have been proposed; the three most common are reproduction, crossover, and mutation. Reproduction consists of simply copying the best solutions from the previous generation into the next, with the intention of preserving very high-quality solutions in the population as-is. Crossover takes two “parents,” randomly chosen, and produces one or more “offspring” that contain some combination of genes from the parents. Crossover can be performed in a deterministic manner (e.g., “one-point” crossover), with genes appearing before a certain cutoff coming from parent 1 and genes after the cutoff coming from parent 2, or in a random manner, with each gene taken from a given parent with a certain probability. The mutation operator changes a few genes randomly, borrowing from the evolutionary concept that random genetic mutations may produce superior offspring (or, of course, inferior offspring, but such individuals are less likely to survive from one generation to the next). Our algorithm does not use mutation, but rather immigration , in which new individuals are generated randomly from scratch, rather than performing random mutations on existing individuals. Each iteration of a standard GA consists of generating a new population using the GA operators. Our GA also uses judiciously applied local improvement heuristics to improve the quality of the individuals in the population without adding excessive computation time. 1.3. Random keys The GA presented in this paper uses random keys to encode solutions. The use of random keys is described in [3] and is useful for problems that require permutations of the integers and for which traditional one- or two-point crossover presents feasibility problems. The technique is best illustrated with an example. Consider a 5-node instance of the classical TSP. Traditional GA encodings of TSP solutions consist of a stream of integers representing the order in which nodes are to be visited by the tour. (That is, the solution 4 2 1 5 3 represents the tour 3 → 2 → 5 → 1 → 4, not the tour 4 → 2 → 1 → 5 → 3.) But one-point crossover, for example, may result in multiple nodes assigned to the same slot on the tour. For example, the parents might produce the children In the random key method, we assign each gene a random number drawn uniformly from [0, 1). To decode the chromosome, we visit the nodes in ascending order of their genes. For example, Random key 0.42 0.06 0.38 0.48 0.81 Decodes as 3 1 2 4 5 (Ties are broken arbitrarily.) Nodes that should be early in the tour tend to “evolve” genes closer to 0 and those that should come later tend to evolve genes closer to 1. Standard crossover techniques will generate children that are guaranteed to be feasible.