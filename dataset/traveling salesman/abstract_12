Password: This paper describes an implementation of the Lin–Kernighan heuristic, one of the most successful methods for generating optimal or near-optimal solutions for the symmetric traveling salesman problem (TSP). Computational tests show that the implementation is highly effective. It has found optimal solutions for all solved problem instances we have been able to obtain, including a 13,509-city problem (the largest non-trivial problem instance solved to optimality today). Keywords Traveling salesman problem ; Heuristics ; Lin–Kernighan The Lin–Kernighan heuristic [1] is generally considered to be one of the most effective methods for generating optimal or near-optimal solutions for the symmetric traveling salesman problem (TSP). However, the design and implementation of an algorithm based on this heuristic is not trivial. There are many design and implementation decisions to be made, and most decisions have a great influence on performance. This paper describes the implementation of a new modified version of the Lin–Kernighan algorithm. Computational experiments have shown that the implementation is highly effective. The new algorithm differs in many details from the original one. The most notable difference is found in the search strategy. The new algorithm uses larger (and more complex) search steps than the original one. Also new is the use of sensitivity analysis to direct and restrict the search. Run times of both algorithms increase approximately as n 2.2 . However, the new algorithm is much more effective. The new algorithm makes it possible to find optimal solutions to large-scale problems, in reasonable running times. For a typical 100-city problem the optimal solution is found in less than a second, and for a typical 1000-city problem optimum is found in less than a minute (on a 300 MHz G3 Power Macintosh). Even though the algorithm is approximate, optimal solutions are produced with an impressively high frequency. It has produced optimal solutions for all solved problems we have been able to obtain, including a 13,509-city problem (at the time of writing, the largest non-trivial problem solved to optimality). Furthermore, the algorithm has improved the best known solutions for a series of large-scale problems with unknown optima, among these an 85,900-city problem. The rest of this paper is organized as follows. Section 2 defines the TSP and gives an overview of solution algorithms. Section 3 describes the original algorithm of Lin and Kernighan (including their own refinements of the algorithm). 4  and  5 present the new modified algorithm and its implementation. The effectiveness of the implementation is reported in Section 6 . 2. The traveling salesman problem 2.1. Formulation A salesman is required to visit each of n given cities once and only once, starting from any city and returning to the original place of departure. What tour should he choose in order to minimize his total travel distance? The distances between any pair of cities are assumed to be known by the salesman. Distance can be replaced by another notion, such as time or money. In the following the term ‘cost’ is used to represent any such notion. This problem, the TSP, is one of the most widely studied problems in combinatorial optimization [2] . Mathematically, the problem may be stated as follows: Given a ‘cost matrix’ C =( c ij ), where c ij represents the cost of going from city i to city j , ( i , j =1,…, n ), find a permutation ( i 1 , i 2 , i 3 ,…, i n ) of the integers from 1 through n that minimizes the quantity Properties of the cost matrix C are used to classify problems. • If c ij = c ji for all i and j , the problem is said to be symmetric ; otherwise, it is asymmetric . • If the triangle inequality holds ( c ik ⩽ c ij + c jk for all i , j and k ), the problem is said to be metric . • If c ij are Euclidean distances between points in the plane, the problem is said to be Euclidean . A Euclidean problem is, of course, both symmetric and metric. 2.2. Solution algorithms The problem is easy to state, but hard to solve. The difficulty becomes apparent when one considers the number of possible tours – an astronomical figure even for a relatively small number of cities. For a symmetric problem with n cities there are ( n  − 1)!/2 possible tours. If n is 20, there are more than 10 18 tours. The 13,509-city problem, which is successfully solved by the algorithm described in this paper, contains about 10 50,000 possible tours. In comparison it may be noted that the number of elementary particles in the universe has been estimated to be ‘only’ 10 87 . It has been proven that TSP is a member of the set of NP-complete problems. This is a class of difficult problems whose time complexity is probably exponential. The members of the class are related so that if a polynomial time were found for one problem, polynomial time algorithms would exist for all of them. However, it is commonly believed that no such polynomial algorithm exists. Therefore, any attempt to construct a general algorithm for finding optimal solutions for the TSP in polynomial time must (probably) fail. Algorithms for solving the TSP may be divided into two classes: • Exact algorithms. • 2.2.1. Exact algorithms The exact algorithms are guaranteed to find the optimal solution in a bounded number of steps. The most effective exact algorithms are cutting-plane or facet-finding algorithms [3] , [4]  and  [5] . These algorithms are quite complex, with codes on the order of 10,000 lines. In addition, the algorithms are very demanding of computer power. For example, it took roughly 3–4 years of CPU time on a large network of computers to determine the exact solution of a 7397-city problem [5] . The previously mentioned 13,509-city problem was solved over a period of three months using a cluster of 3 servers, a total of 12 processors, and 32 PCs [6] . 2.2.2. Approximate algorithms In contrast, the approximate algorithms obtain good solutions but do not guarantee that optimal solutions will be found. These algorithms are usually very simple and have (relatively) short running times. Some of the algorithms give solutions that in average differs only by a few percent from the optimal solution. Therefore, if a small deviation from optimum can be accepted, it may be appropriate to use an approximate algorithm. The class of approximate algorithms may be subdivided into the following three classes: • Tour construction algorithms . • Tour improvement algorithms . • Composite algorithms . The tour construction algorithms gradually build a tour by adding a new city at each step. The tour improvement algorithms improve upon a tour by performing various exchanges. The composite algorithms combine these two features. A simple example of a tour construction algorithm is the so-called nearest - neighbor algorithm : Start in an arbitrary city. As long as there are cities, that have not yet been visited, visit the nearest city that still has not appeared in the tour. Finally, return to the first city. A simple example of a tour improvement algorithm is the so-called 2 - opt algorithm : Start with a given tour. Replace 2 links of the tour with 2 other links in such a way that the new tour length is shorter. Continue in this way until no more improvements are possible. Fig. 1 illustrates a 2-opt exchange of links, a so-called 2- opt move . Note that a 2-opt move keeps the tour feasible and corresponds to a reversal of a subsequence of the cities. Fig. 1.  A generalization of this simple principle forms the basis for one the most effective approximate algorithms for solving the symmetric TSP, the Lin – Kernighan algorithm [1] .