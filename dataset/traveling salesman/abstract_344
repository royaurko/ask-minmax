Password: One of the major strengths of Constraint Programming is the flexibility and expressiveness of models in that computational paradigm, which make it easy to add problem-dependent constraints without having to modify the solution strategy. We show here what needs to be done in order to adapt a constraint programming algorithm for the traveling salesman problem with time windows so that it can handle multiple time windows. Computational results are also presented on a set of instances created for that little-studied problem. Keywords Traveling salesman ; Multiple time windows ; Constraint programming ; Branch and bound ; Iterative-cost-deepening 1. Introduction An exact constraint programming (CP) algorithm to solve the traveling salesman problem with time windows (TSPTW) was introduced in [18] . The authors mentioned that the algorithm could be easily adapted to solve related routing problems. In order to stress that flexibility of CP models, we show here how a generalization to the traveling salesman problem with multiple time windows (TSPMTW) can be handled with that same algorithm. This generalization to multiple time windows is interesting from a theoretical point of view and often necessary from a practical perspective. For example, [2] describe a scheduling problem for the distribution of industrial gases where clients are not open for delivery on every day of the week or every hour of the day, naturally inducing multiple time windows. The growing impact of CP in combinatorial optimization and even beyond [23] is related to its flexible modeling capabilities, especially attractive in real-life situations, and to the elegant framework it provides for combining established specialized algorithms from many disciplines, notably operations research. It has had success in several areas such as scheduling 1 , 5 , 16  and  17 , routing 4 , 6 , 19  and  18 and timetabling 3 , 11  and  24 . The TSPMTW is a difficult problem on which little has been published to date. We survey here related work on multiple time windows. Ref. [10] consider a variation of the vehicle routing problem in which the time taken to make a delivery is dependent on delivery size and which allows splitting a delivery to a customer among several vehicles. Customers have multiple time windows, one or several of which may be used for the delivery. The authors use a construction heuristic based on a dynamic urgency classification of customers followed by simple node-exchange improvement heuristics. They report computational results on problems where the number of time windows per customer is at most two. Ref. [2] consider an industrial gases distribution application where they must maintain customer supply at on-site tanks. Their problem features inventory control, demand forecasting, dynamic rescheduling to accommodate emergency orders, split deliveries and multiple time windows. They use a Lagrangian relaxation of a mixed integer programming formulation to solve these large routing and scheduling problems over a two- to five-day horizon. In the area of automated manufacturing systems, [12] develop a shortest time path algorithm for automated guided vehicles on a network of track segments. In their approach, vehicles are routed one by one and previously planned paths cannot be changed. Because two vehicles may not concurrently occupy the same track segment, the previously routed vehicles impose time exclusion periods on track segments which are modeled as multiple time windows for the current vehicle. The remainder of the paper is organized as follows. Section 1 recalls the model of [18] and describes its adaptation to the new context. Section 2 proposes a strategy to create initial upper bounds for our branch-and-bound algorithm. Section 3 describes how the test set was generated while Section 4 reports and analyses computational results on that set. 2. Adapting the constraint model Some of this section is borrowed from [18] ; the interested reader is referred to that paper for additional details. When solving combinatorial optimization problems with constraint programming, a domain is associated with every variable of the model for the problem at hand: each value in that domain represents a possible value for the variable. The constraints of the model forbid certain combinations of values for the variables; for example, given the same domain {1,2,3} for variables x , y and z , the constraint x + y ⩽ z forbids solution x =3; y =1; z =2 in particular and any solution in which z =1 in general. The constraint satisfaction algorithm (or solver ) used in CP filters out inconsistent values from the domains (for example the value 1 from the domain of z above), thus discarding whole regions of the solution space. Looking locally at a particular constraint, it attempts to reduce the domain of each variable involved in that constraint by removing values which cannot be part of any solution because they would violate that individual constraint; this local consistency step can be performed efficiently. The reduction of a variable's domain triggers the examination of all constraints involving this variable, which in turn may reduce the domain of other variables. This recursive process stops when either no new domain reduction has taken place or a domain becomes empty, in which case no solution exists. The overall behavior is called constraint propagation . Since constraint propagation may terminate with indeterminate variables (i.e. whose domain still contains several values), the solution process requires search and its potentially exponential cost. It usually takes the form of a branch-and-bound search in which branching corresponds to fixing a variable to a value in its domain (thus triggering propagation) and bounding is obtained by looking at the smallest value left in the domain of the cost variable. The TSPTW consists of finding a minimum cost tour of a set of cities where each city is visited exactly once. To be feasible, the tour must start and end at a unique depot within a certain time window and each city must be visited within its own time window. Early arrival is allowed but implies a waiting time until the beginning of the window. Let V ={2,…, n } represent the cities to visit and duplicate the unique depot into an origin-depot and a destination-depot, identified as 1 and n +1, respectively. A tour thus becomes a Hamiltonian path starting at 1 and ending at n +1. For convenience, define V o = V ∪{1} and V d = V ∪{ n +1}. For each pair of cities i and j , let t ij denote the travel time from i to j and c ij the travel cost from i to j . Let interval [ a i , b i ] describe the time window at city i . The two main sets of variables are , where S i ∈{2,…, n +1} represents the immediate successor of i on the tour, and , where T i represents the time at which service begins at i . As values are given to the S i 's, corresponding partial (directed) paths are formed. Let β i and ϵ i respectively denote the beginning and end of the current partial path through i ; initially, β i = ϵ i = i .