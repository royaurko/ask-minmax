The performance of a dynamic dictionary is measured mainly by its update
time, lookup time, and space consumption. In terms of update time and lookup
time there are known constructions that guarantee constant-time operations in
the worst case with high probability, and in terms of space consumption there
are known constructions that use essentially optimal space. However, although
the first analysis of a dynamic dictionary dates back more than 45 years ago
(when Knuth analyzed linear probing in 1963), the trade-off between these
aspects of performance is still not completely understood. In this paper we
settle two fundamental open problems: - We construct the first dynamic
dictionary that enjoys the best of both worlds: it stores n elements using
(1+epsilon)n memory words, and guarantees constant-time operations in the worst
case with high probability. Specifically, for any epsilon = \Omega((\log\log n
/ \log n)^{1/2} ) and for any sequence of polynomially many operations, with
high probability over the randomness of the initialization phase, all
operations are performed in constant time which is independent of epsilon. The
construction is a two-level variant of cuckoo hashing, augmented with a
"backyard" that handles a large fraction of the elements, together with a
de-amortized perfect hashing scheme for eliminating the dependency on epsilon.
- We present a variant of the above construction that uses only (1+o(1))B bits,
where B is the information-theoretic lower bound for representing a set of size
n taken from a universe of size u, and guarantees constant-time operations in
the worst case with high probability, as before. This problem was open even in
the amortized setting. One of the main ingredients of our construction is a
permutation-based variant of cuckoo hashing, which significantly improves the
space consumption of cuckoo hashing when dealing with a rather small universe.