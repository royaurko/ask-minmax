Prolog's very useful expressive power is not captured by traditional logic
programming semantics, due mainly to the cut and goal and clause order. Several
alternative semantics have been put forward, exposing operational details of
the computation state. We propose instead to redesign Prolog around structured
alternatives to the cut and clauses, keeping the expressive power and
computation model but with a compositional denotational semantics over much
simpler states-just variable bindings. This considerably eases reasoning about
programs, by programmers and tools such as a partial evaluator, with safe
unfolding of calls through predicate definitions. An if-then-else across
clauses replaces most uses of the cut, but the cut's full power is achieved by
an until construct. Disjunction, conjunction and until, along with unification,
are the primitive goal types with a compositional semantics yielding sequences
of variable-binding solutions. This extends to programs via the usual technique
of a least fixpoint construction. A simple interpreter for Prolog in the
alternative language, and a definition of until in Prolog, establish the
identical expressive power of the two languages. Many useful control constructs
are derivable from the primitives, and the semantic framework illuminates the
discussion of alternative ones. The formalisation rests on a term language with
variable abstraction as in the {\lambda}-calculus. A clause is an abstraction
on the call arguments, a continuation, and the local variables. It can be
inclusive or exclusive, expressing a local case bound to a continuation by
either a disjunction or an if-then-else. Clauses are open definitions, composed
(and closed) with simple functional application ({\beta}-reduction). This paves
the way for a simple account of flexible module composition mechanisms. Cube, a
concrete language with the exposed principles, has been implemented.