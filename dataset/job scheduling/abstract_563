Password: There is an extensive literature on models that integrate scheduling with batching decisions. Jobs may be batched if they share the same setup on a machine. Another reason for batching occurs when a machine can process several jobs simultaneously. This paper reviews the literature on scheduling with batching, giving details of the basic algorithms, and referencing other significant results. Special attention is given to the design of efficient dynamic programming algorithms for solving these types of problems. Keywords Scheduling ; Batching ; Families ; Review ; Complexity ; Algorithm ; Dynamic programming ; Approximation 1. Introduction In the last decade, there has been significant interest in scheduling problems that involve an element of batching. In this context, the motivation for batching jobs is a gain in efficiency: it may be cheaper or faster to process jobs in a batch than to process them individually. One situation where benefits may result from batching occurs when machines require setups if they are to process jobs that have differing characteristics. The setup may reflect the need to change a tool or to clean the machine. In a family scheduling model , jobs are partitioned into families according to their similarity, so that no setup is required for a job if it belongs to the same family of the previously processed job. However, a setup time is required at the start of the schedule and on each occasion when the machine switches from processing jobs in one family to jobs in another family. In this model, a batch is a maximal set of jobs that are scheduled contiguously on a machine and share a setup. Large batches have the advantage of high machine utilization because the number of setups is small. On the other hand, processing a large batch may delay the processing of an important job belonging to a different family. There are two variants of the family scheduling model depending on when the jobs become available (either for dispatch to the customer or to be processed on the next machine). Under batch availability , a job only becomes available when the complete batch to which it belongs has been processed. For example, this situation occurs if the jobs in a batch are placed on a pallet, and the pallet is only moved from the machine when all of these jobs are processed. An alternative assumption is job availability (usually known in the literature as item availability), in which a job becomes available immediately after its processing is completed. Unless stated otherwise, we adopt the assumption of job availability. Another situation where batching may result in improved efficiency occurs when a batching machine is capable of processing several jobs simultaneously. For example, `burn in' operations in the manufacture of circuit boards are performed in ovens that can accommodate several jobs. Other applications occur for chemical processes that are performed in tanks or kilns. In these cases, a batching machine processes a batch of jobs at the same time, where there is sometimes an upper limit on the batch size. There are reviews of models which combine scheduling with batching by Potts and Van Wassenhove [63] and Webster and Baker [79] . In this paper, we provide an updated review which includes many of the more recent results in this area. Our review provides a classification of problems as polynomially or pseudopolynomially solvable, binary or unary NP-hard (NP-hard in the ordinary or strong sense), or open. Also, we describe enumerative algorithms, heuristic procedures and local search methods, and indicate their efficiency and effectiveness. Moreover, our review covers approximation algorithms and their worst-case performance. The remainder of this paper is organized as follows. In Section 2 , we give a more formal definition of the models under consideration. Section 3 explains how dynamic programming algorithms can be designed to give efficient algorithms for several of the problems that we consider. 4  and  5 review the family scheduling model and the batching machine model, respectively. Finally, some concluding remarks are contained in Section 6 . 2. Problem specification We consider problems involving the scheduling of a single machine, of m parallel machines, and of m -machine flow shops, job shops and open shops. For the case of parallel machines, the machines may either be identical, uniform, or unrelated, which means that the processing time of a job on a machine depends only on the job, depends only on the job and the speed of the machine to which it is assigned, or depends both on the job and the machine to which it is assigned, respectively. For the flow shop, each job has m operations, the first of which requires processing on machine 1, the second requires processing on machine 2, and so on, and the last requires processing on machine m . For the job shop, each job has a given sequence of operations on the machines, so that different jobs pass through the machines in a different order. For the open shop, each job has an operation on each of the m machines, but the processing order of these operations can be chosen. Each machine may either be of a classical type that can handle at most one job at a time, or it may be a batching machine that can process several jobs simultaneously. For a batching machine, the processing time of a batch is the maximum of the processing times of jobs or operations contained in the batch. Further, each job or operation in the batch has the same completion time, which is the time that the batch completes processing. Let {1,…, n } denote the set of jobs to be processed. For a single-machine problem, we denote the processing time of job j , for j =1,…, n , by p j . (For other machine environments, we do not need to introduce notation for processing times.) Other parameters of job j that occur in some problems include a release date r j , a deadline , a due date d j , and a weight w j . In the family scheduling model, the jobs are partitioned into F families. Let n f denote the number of jobs in family f , for f =1,…, F . No setup is required between jobs of the same family. However, the family setup time on machine i when a job of family g is immediately preceded by a job of a different family f is s ifg , or s i 0 g if there is no preceding job. If, for each g , we can write s ifg = s i 0 g = s ig for all f ≠ g , then the setup times on machine i are sequence independent ; otherwise, they are sequence dependent . If, for each machine i , s ifg = s fg for all families f and g including the case f =0, then the setup times are machine independent ; otherwise, they are machine dependent . For the case of a single machine, setup times are, by definition, machine independent. Further, we make the reasonable assumption that the triangle inequality holds for each machine i , which means that s ifh ⩽ s ifg + s igh , for all distinct families f , g and h , including the case f =0. Unless stated otherwise, the setups are assumed to be anticipatory , which means that a setup on a machine does not require the presence of any job. When there are release dates and for shop problems, we sometimes allow setups to be non-anticipatory , which means that the setup preceding the processing of some batch cannot start on the current machine before all jobs of this batch are released and have completed their processing on any previous machine. For the case of sequence-independent family setup times and batch availability, there may be two or more successive batches of the same family. In such a case, a family setup time is required before a batch is processed, even it is of the same family as the previous batch. If there is a maximum batch size for any machine i , we denote it b i . In the case of a single machine, or if restrictions on batch sizes are the same for all machines, we let b denote any maximum batch size that is imposed.