  This paper presents a predictable and grouped genetic algorithm (PGGA) for job scheduling. The novelty of the PGGA is two-fold: (1) a job workload estimation algorithm is designed to estimate a job workload based on its historical execution records and (2) the divisible load theory (DLT) is employed to predict an optimal fitness value by which the PGGA speeds up the convergence process in searching a large scheduling space. Comparison with traditional scheduling methods, such as first-come-first-serve (FCFS) and random scheduling, heuristics, such as a typical genetic algorithm, Min–Min and Max–Min indicates that the PGGA is more effective and efficient in finding optimal scheduling solutions. Keywords Job scheduling ; Job workload estimation ; Divisible load theory ; Predictable genetic algorithm ; Load balancing 1. Introduction The Grid [1] is emerging as a large scale, distributed computing infrastructure that promises to support resource sharing and coordinated problem solving in dynamic, multi-institutional virtual organisations [2] . Job scheduling, which is defined as a process of mapping jobs to resources, plays a crucial role in a Grid environment. A scheduling system has the responsibility of selecting resources and scheduling jobs in such a way that the user and application requirements are met. There are many research efforts aiming at job scheduling on the Grid, notably, Condor-G [3] , AppLeS [4] and Nimrod-G [5] . However, scheduling m jobs to n resources with an objective to minimize the total execution time (makespan) has been shown to be NP-complete [6] . Heuristics, such as genetic algorithms (GAs) have been used for optimising m / n type job scheduling. When performing m / n type job scheduling, traditional GAs use a large number of iterations to produce an optimal or a near optimal scheduling solution by ranking the fitness value of each chromosome in a generation. One major problem with these GAs is that they cannot dynamically predict an optimal fitness value using historical execution records of the jobs to be scheduled. Therefore, the fitness of a scheduling solution produced by a GA is largely dependent on the number of generations (iterations) used in the evolution process. While a large number of iterations could produce a better scheduling solution than a small number of iterations, the cost is that more time is needed. Braun et al. [7] also conclude that, among the reviewed eleven heuristics for mapping a class of independent tasks onto heterogeneous distributed computing systems, the GA has the overall best performance in producing scheduling solutions but takes the most expensive search time. A successful job scheduling using GAs should be quick enough to produce an optimal or a near optimal scheduling solution in terms of a large number of jobs and computing resources. In this paper, we present a predictable and grouped genetic algorithm (PGGA) for m / n type job scheduling. The PGGA is novel in two aspects. On the one hand, it estimates a job workload using historical execution records of the job. On the other hand, it dynamically predicts an optimal fitness value based on the divisible load theory (DLT) [8] to speed up the convergence process in producing an optimal or a near optimal scheduling solution. The remainder of this paper is organized as follows. Section 2 presents the job workload estimation algorithm. Section 3 implements a typical genetic algorithm (TGA) for job scheduling, and then extends the TGA to the PGGA based on the DLT. Section 4 uses simulations and real tests to evaluate the performance of the PGGA. Section 5 gives related work on job scheduling with GAs and Section 6 concludes this paper. 2. A job workload estimation algorithm Jobs considered in the algorithm are independent and indivisible. Computing nodes used in a cluster environment are dedicated PCs and have the same architecture but with different computing capabilities. Each job has an input with a certain size and a unique job name. We only consider computing capability as the performance metric of a computing node in the algorithm. Furthermore, the communication cost to send a job from one computing node to another is not considered in the algorithm as the network bandwidth in a cluster environment is normally fixed. Let • J k be the name of a job, k ∈{1, 2, …, m }. • J k ( d ) be a job of J k with a size of d . • T ( J k ( d )) be the amount of time needed to execute J k ( d ). T ( J k ( d )) can be measured from the execution of J k ( d ). • P i be a computing node, i ∈{1, 2, …, n }. • F ( P i ) be the computing capability of node P i . • U ( P i ) be the utilisable rate of node P i . • W ( J k ( d )) be the workload of job J k ( d ). For a job J k ( d ) to run on a computing node P i , we have equation ( 1 ) Let • LS k ( ) represent the slope of a line formed by any two neighbouring points of job J k . • R be a list and R  = {(LS 1 ( )) * , (LS 2 ( )) * , …, (LS k ( )) * , …, (LS m ( )) * }, where (LS k ( )) * means that the number of records of LS k ( ) in R is greater than or equal to zero. • X  = | d a  −  d b |, Y  = | W ( J k ( d a )) −  W ( J k ( d b ))|, d a  ≠  d b . • H be a set of historical job execution records. • Q 1 be a queue for jobs without estimated workload values. • Q 2 be a queue for jobs with estimated workload values.