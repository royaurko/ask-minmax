Password: In a scheduling problem, a job is said to be fixed when its due date corresponds exactly to its release date plus its processing time. This paper addresses the fixed job scheduling problem where processors are subject to spread time constraints, i.e., the amount of time spent between the starting time of the first job on a processor and the completion time of the last job on the same processor should not exceed a given duration. Existing exact approaches are tested on medium size instances. As large instances are clearly intractable with these approaches, a greedy heuristic and a grouping genetic algorithm are proposed. Computational results show the effectiveness of the proposed heuristics. Keywords Fixed job scheduling ; Spread time constraints ; Genetic algorithms 1. Introduction The Fixed Job Scheduling (denoted FJS) problem is a particular case of interval scheduling problems: each job j   has a weight w j w j , a ready time r j r j and a due date d j d j such that the job processing time is d j -r j d j - r j . The weight is typically a measure of the gain earned by processing the corresponding job. These jobs are to be processed by parallel identical processors without preemption. FJS has two versions that differ in their objective functions. In the operational version, denoted OFJS, the number of available processors m is given and the problem is to select jobs for processing so as to maximize their total weight. This problem is addressed in [1] . In the tactical version, denoted TFJS, all the jobs have to be processed and the problem is to minimize m , the number of processors required for processing all the jobs regardless of their weight. Note that TFJS can easily be solved by finding the maximum cardinality set of overlapping jobs over time. This problem is addressed in [10] with additional constraints and applied to staff capacity planning in the field of aircraft maintenance. A simulated annealing approach for this problem can also be found in [15] . A similar problem arises when minimizing the number of operators in electronic chip design [12] . In another variant (see [9] ), FJS is solved in the case of processor classes, and this has an impact on jobs gain. That case can be regarded as FJS with multi-purpose machines. Fixed Job Scheduling problems are more difficult to solve when spread time constraints have to be met. Spread time constraints can be stated as follows: the duration between the starting time and the completion time of any pair of jobs allocated to the same processor has to be less than or equal to a given duration T . This kind of constraints is appropriate for modeling work regulations: the bus driver scheduling problem [6]  and  [7] is a typical application of FJS with spread time constraint. This paper addresses the operational version of fixed job scheduling problem, denoted OFJSST. A branch-and-bound exact algorithm is proposed in [3] , and is tested on a set of instances for which the number of jobs is in {20,40,80,100} { 20 , 40 , 80 , 100 } , these instances are referred to as medium size instances throughout this paper. They also report that the proposed branch-and-bound fails to solve all of the medium size instances to optimality whenever n is larger than 60 jobs. In this paper, it is first shown that OFJSST can also be formulated as an integer programming problem. This formulation proves to be very competitive as the commercial solver XPress MP [8]  and  [11] with basic settings is able to solve any of the medium size instances in less than 4 min. As exact methods are impracticable for larger instances, two heuristic approaches are proposed for OFJSST. A greedy heuristic, referred to as GH, is first devised which iteratively allocates the processors to a set of jobs whose sum of the weights is high. As metaheuristics have been successful in solving combinatorial optimization problems for a long time, we therefore designed a grouping genetic algorithm, referred to as GGA. OFJSST can be seen as a grouping problem [4]  and  [5] since an optimal assignment of a given set of objects (tasks) according to a given cost function is searched for in different groups (processors) subject to some constraints. Therefore, when designing a genetic algorithm for this problem, genetic operators should be designed in such a way that these operators try to preserve grouping information (i.e., scheduling information) while generating new chromosomes [4]  and  [5] . The genetic algorithm that this paper describes for the OFJSST problem is designed with exactly the aforementioned idea. Falkenauer [4]  and  [5] names this type of genetic algorithm a grouping genetic algorithm . The proposed grouping genetic algorithm is first compared to the integer programming model on medium size instances, proving to yield very high quality solutions. It is then tested on some larger problem instances and its quality is assessed by comparing it with the aforementioned greedy heuristic GH. To our knowledge these are the first heuristics for the OFJSST. This paper is organized as follows. Section 2 presents an exact method based on a previously published integer programming model. A greedy heuristic for OFJSST is delineated in Section 3 and a grouping genetic algorithm is presented in Section 4 . Computational results are reported and discussed in Section 5 . Finally, Section 6 outlines some conclusions.