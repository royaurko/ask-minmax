Password: We consider the NP-hard problem of scheduling jobs on a single machine against common due dates with respect to earliness and tardiness penalties. The paper covers two aspects: Firstly, we develop a problem generator and solve 280 instances with two new heuristics to obtain upper bounds on the optimal objective function value. Secondly, we demonstrate computationally that our heuristics are efficient in obtaining near-optimal solutions for small problem instances. The generated problem instances in combination with the upper bounds can be used as benchmarks for future approaches in the field of common due-date scheduling. Scope and purpose In connection with just-in-time production and delivery, earliness as well as tardiness penalties are of interest. Thus scheduling against common due dates has received growing attention during the last decade. Many algorithms have been developed to solve the different variants of this problem. But whenever a new algorithm for scheduling against common due dates is proposed, its quality is assessed only on a few self-generated examples. Hence it is difficult to evaluate the various approaches, particularly in comparison with each other. Therefore the goal of this paper is to present numerous benchmark problems together with some upper bounds on the optimal objective function value. Keywords Scheduling ; Common due date ; Benchmark 1. Introduction Common due-date problems have been studied extensively during the last 20 years. In practice, a common due date occurs, for example, if in an assembly schedule a set of jobs is needed simultaneously, see Kanet [1] , or if one customer orders a bundle of perishable goods which have to be delivered at a prespecified time. When scheduling on a single machine against a common due date, one job at most can be completed exactly at the due date. Hence, some of the jobs have to be completed early, that is prior to the due date, while other jobs must be finished late. In both cases certain costs are incurred: early jobs tie up capital and cause holding costs while the effects of tardy jobs are dissatisfied customers and thus — in the long run — the loss of goodwill and reputation. In this context the goal is to find a schedule which jointly minimizes the sum of earliness and tardiness costs. Generally speaking, there are two classes of common due-date problems which have proven to be NP-hard, namely if a restrictive common due date is given or if different jobs incur different penalties. In this paper we propose benchmarks for both classes of problems. This is done by the generation of restrictive common due-date problems with distinct and job-individual earliness and tardiness penalties, which seem to be the most difficult problems in this area of research. The following section introduces the problem formulation and gives a short review of the literature on scheduling against common due dates. In the third section the idea and application of a short Pascal code to generate benchmark problems is described, for which we calculate upper bounds from two heuristics presented in the forth section. 2. Problem formulation There are n jobs available at time zero, which have to be processed on a single machine. Each of these jobs needs exactly one operation. The processing times p i of the jobs i =1,…, n are deterministic and known, preemption of jobs is not allowed. If the completion time C i of job i is smaller than or equal to the common due date d , which is assumed as given, the jobs’ earliness is E i = d − C i . Accordingly, a job i is tardy with the tardiness T i = C i − d , if its completion time is greater than the common due date d . As it is not known in advance whether a job will be completed before or after the due date, earliness and tardiness are calculated as and for all jobs i =1,…, n . The per time unit penalties of the job i for being early or tardy are α i and β i , respectively. The objective is to jointly minimize the sum of earliness and tardiness penalties equation ( 1 ) where S denotes a feasible schedule of the jobs. To distinguish the terms ‘sequence’ and ‘schedule’, which are often used synonymously, we refer to a sequence π as the order in which the jobs are processed. A schedule S on the other hand contains all the information necessary for the manufacture of the jobs, that is, the sequence of the jobs, the starting time of the first job (it is easy to show that idle times between consecutive jobs cannot be advantageous in common due-date scheduling) and the common due date. Only if these three pieces of information are given, has a schedule been described completely. In objective function (1) , the common due date d might be a decision variable whose value has to be determined, or it might have been given externally. Suppose a due date d >∑ i =1 n p i is given; an (global) optimal schedule S ∗ with the sequence π ∗ of the jobs around this due date and its objective function value f(S ∗ ) can be constructed. A common due date is called unrestrictive as long as the optimal schedule S ∗ (with f(S ∗ ) ) can be realized. Obviously, an (externally) given common due date, for which d ⩾∑ i =1 n p i holds, is unrestrictive. Furthermore, the due date is called unrestrictive if it is a decision variable. To summarize, we refer to a common due date as unrestrictive, if the optimal sequence π ∗ can be constructed without considering the (value of) the due date. Otherwise the common due date is called restrictive. For a good introduction to common due-date problems, see Baker and Scudder [2] . In the following, the most important complexity results for unrestrictive and restrictive common due-date scheduling problems are summarized.